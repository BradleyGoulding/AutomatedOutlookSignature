[CmdletBinding()]
param (
    [Parameter()]
    [ValidateNotNullOrEmpty()]
    [string]
    $CompanyName,
    [Parameter()]
    [ValidateNotNullOrEmpty()]
    [string]
    $Website,
    [Parameter()]
    [ValidateNotNullOrEmpty()]
    [ValidateSet("ascii", "utf8", "unicode", "utf32")]
    [string]
    $Encoding = "unicode"
)

<#
.SYNOPSIS
    Automated Outlook Signature

.DESCRIPTION
    Longer more detailed description

.NOTES
    Author           : CaptainQwerty
    Release Date     : 19/05/2024
    Script Version   : 5.0.0
    GitHub Repo      : https://github.com/CaptainQwerty/AutomatedOutlookSignature
    ReadMe           : https://github.com/CaptainQwerty/AutomatedOutlookSignature/blob/main/README.md
#>

<#-----[ Latest Patch Notes ]-----#

Version 5.0.0
    * New script layout utilising functions to help with readability
    * Now Supports Verbose
    * Support for paramaters with the script execution
    * Now utilises a class to help with readability
    * Fixed Office for more versions of Office
    * Removed the group check example as this increases the scripts run time by too much
    * encoding can be easily switch with a parameter 

#>

# [ Configuration ]

Write-Verbose "Version 5.0.0"
$logo = "https://example.com/logo.png"
$folderLocation = Join-Path -Path $Env:appdata -ChildPath 'Microsoft\signatures'
$fileName = 'Signature'
$file  = Join-Path -Path $folderLocation -ChildPath $fileName

# [ Classes ]

class UserAccount {
    [string]$Name
    [string]$DistinguishedName
    [string]$UserPrincipalName
    [string]$DisplayName
    [string]$GivenName
    [string]$Initials
    [string]$Surname
    [string]$Description
    [string]$JobTitle
    [string]$Department
    [string]$Company
    [string]$EmailAddress
    [string]$StreetAddress
    [string]$City
    [string]$State
    [string]$PostalCode
    [string]$Country
    [string]$TelephoneNumber
    [string]$Mobile
    [string]$Pager
    [string]$Fax
    [string]$HomePhoneNumber
    [string]$OtherHomePhoneNumber
    [string]$HomeFax
    [string]$OtherFax
    [string]$IPPhone
    [string]$OtherIPPhone
    [string]$WebPage
    [string]$ExtensionAttribute1
    [string]$ExtensionAttribute2
    [string]$ExtensionAttribute3
    [string]$ExtensionAttribute4
    [string]$ExtensionAttribute5
    [string]$ExtensionAttribute6
    [string]$ExtensionAttribute7
    [string]$ExtensionAttribute8
    [string]$ExtensionAttribute9
    [string]$ExtensionAttribute10
    [string]$ExtensionAttribute11
    [string]$ExtensionAttribute12
    [string]$ExtensionAttribute13
    [string]$ExtensionAttribute14
    [string]$ExtensionAttribute15
}

# [ Functions ]

function Get-UserDetails {
    [CmdletBinding()]
    param ()

    try {
        $user = (([adsisearcher]"(&(objectCategory=User)(samaccountname=$env:username))").FindOne().Properties)
        Write-Verbose "User found for $($env:username)"

        $userAccount = New-Object UserAccount
        $userAccount.Name = $user['name'] -join ''
        $userAccount.DistinguishedName = $user['distinguishedname'] -join ''
        $userAccount.UserPrincipalName = $user['userprincipalname'] -join ''
        $userAccount.DisplayName = $user['displayname'] -join ''
        $userAccount.GivenName = $user['givenname'] -join ''
        $userAccount.Initials = $user['initials'] -join ''
        $userAccount.Surname = $user['sn'] -join ''
        $userAccount.Description = $user['description'] -join ''
        $userAccount.JobTitle = $user['title'] -join ''
        $userAccount.Department = $user['department'] -join ''
        $userAccount.EmailAddress = $user['mail'] -join ''
        $userAccount.StreetAddress = $user['streetaddress'] -join ''
        $userAccount.City = $user['l'] -join ''
        $userAccount.State = $user['st'] -join ''
        $userAccount.PostalCode = $user['postalcode'] -join ''
        $userAccount.Country = $user['c'] -join ''
        $userAccount.TelephoneNumber = $user['telephonenumber'] -join ''
        $userAccount.Mobile = $user['mobile'] -join ''
        $userAccount.Pager = $user['pager'] -join ''
        $userAccount.Fax = $user['facsimiletelephonenumber'] -join ''
        $userAccount.HomePhoneNumber = $user['homephone'] -join ''
        $userAccount.OtherHomePhoneNumber = $user['otherhomephone'] -join ''
        $userAccount.HomeFax = $user['homefax'] -join ''
        $userAccount.OtherFax = $user['otherfacsimiletelephonenumber'] -join ''
        $userAccount.IPPhone = $user['ipphone'] -join ''
        $userAccount.OtherIPPhone = $user['otheripphone'] -join ''

        $userAccount.Company = if ($null -eq $CompanyName) { $user['company'] } else { $CompanyName }
        $userAccount.WebPage = if ($null -eq $Website) { $user['wWWHomePage'] } else { $Website }
        
        $userAccount.ExtensionAttribute1 = $user['extensionattribute1'] -join ''
        $userAccount.ExtensionAttribute2 = $user['extensionattribute2'] -join ''
        $userAccount.ExtensionAttribute3 = $user['extensionattribute3'] -join ''

        return $userAccount
    } catch {
        Write-Error "Unable to query Active Directory for user information. Details: $($_.Exception.Message)"
        exit 1
    }
}

function Set-RegistryEntries {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [string] $Version,
        [Parameter(Mandatory = $true)]
        [string] $SignatureName
    )

    $regPathGeneral = "HKCU:\Software\Microsoft\Office\$Version\Common\General"
    $regPathMailSettings = "HKCU:\Software\Microsoft\Office\$Version\Common\MailSettings"
    $regPathOutlookSetup = "HKCU:\Software\Microsoft\Office\$Version\Outlook\Setup"

    Write-Verbose "Setting registry keys"
    New-ItemProperty -Path $regPathGeneral -Name "Signatures" -Value "signatures" -PropertyType String -Force | Out-Null
    New-ItemProperty -Path $regPathMailSettings -Name "NewSignature" -Value $SignatureName -PropertyType String -Force | Out-Null
    New-ItemProperty -Path $regPathMailSettings -Name "ReplySignature" -Value $SignatureName -PropertyType String -Force | Out-Null

    Write-Verbose "Removing First-Run registry key"
    Remove-ItemProperty -Path $regPathOutlookSetup -Name "First-Run" -ErrorAction SilentlyContinue | Out-Null
}

function Get-OfficeVersion {
    [CmdletBinding()]
    param ()

    Write-Verbose "Getting office version"
    $officeVersions = @("16.0", "15.0", "14.0")
    $basePath = "HKCU:\Software\Microsoft\Office\"

    foreach ($version in $officeVersions) {
        $path = $basePath + $version + "\Outlook"
        if (Test-Path -Path $path) {
            Write-Verbose "Office Version: $version"
            return $version
        }
    }

    Write-Error "No compatible version of Microsoft Office found."
    exit 1
}

function Get-SignatureHTML {
    [CmdletBinding()]
    param (
        [UserAccount]$user
    )

    Write-Verbose "Building HTML from template"

    try {
        $templatePath = Join-Path -Path $PSScriptRoot -ChildPath "template.html"
        if (-not (Test-Path -Path $templatePath)) {
            Write-Error "HTML template file not found at: $templatePath"
            exit 1
        }
        
        $template = Get-Content -Path $templatePath -Raw
        
        # Use Invoke-Expression to evaluate the template with variables
        $expandedTemplate = $ExecutionContext.InvokeCommand.ExpandString($template)
        
        return $expandedTemplate
    } catch {
        Write-Error "Error reading or processing HTML template: $($_.Exception.Message)"
        exit 1
    }
}

function Get-SignaturePlainText {
    [CmdletBinding()]
    param (
        [UserAccount]$user
    )

    Write-Verbose "Building Plain Text from template"

    try {
        $templatePath = Join-Path -Path $PSScriptRoot -ChildPath "template.txt"
        if (-not (Test-Path -Path $templatePath)) {
            Write-Error "Plain text template file not found at: $templatePath"
            exit 1
        }
        
        $template = Get-Content -Path $templatePath -Raw
        
        # Use Invoke-Expression to evaluate the template with variables
        $expandedTemplate = $ExecutionContext.InvokeCommand.ExpandString($template)
        
        return $expandedTemplate
    } catch {
        Write-Error "Error reading or processing plain text template: $($_.Exception.Message)"
        exit 1
    }
}

# [ CSS ]

$style = 
@"
<style>
p, table, a, span { 
    font-family: Arial, Helvetica, sans-serif;
    font-size:  12pt;
}
</style>
"@

# [ Execution ]

$officeVersion = Get-OfficeVersion
$user = Get-UserDetails

# If the folder does not exist create it
if (-not (Test-Path -Path $folderLocation)) {
    try {
        Write-Verbose "Creating Director: $folderLocation"
        New-Item -ItemType directory -Path $folderLocation
    } catch {
        Write-Error "Error: Unable to create the signatures folder. Details: $($_.Exception.Message)"
        exit
    }
}

$htmlSignature = Get-SignatureHTML -user $user
$plainTextSignature = Get-SignaturePlainText -user $user

# Save the HTML to the signature file
try {
    Write-Verbose "Saving HTML signature"
    $style + $htmlSignature | Out-File -FilePath "$file.htm" -Encoding $Encoding
} catch {
    Write-Error "Error: Unable to save the HTML signature file. Details: $($_.Exception.Message)"
    exit 1
}

# Output the text to the signatures folder
try {
    Write-Verbose "Saving txt signature"
    $plainTextSignature | out-file "$file.txt" -encoding $Encoding
} catch {
    Write-Error "Error: Unable to save the text signature file. Details: $($_.Exception.Message)"
    exit 1
}

Set-RegistryEntries -Version $officeVersion -SignatureName $fileName